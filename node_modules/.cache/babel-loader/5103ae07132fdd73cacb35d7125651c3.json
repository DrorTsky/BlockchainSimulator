{"ast":null,"code":"const SHA256 = require('crypto-js/sha256');\n\nconst EC = require('elliptic').ec;\n\nconst ec = new EC('secp256k1');\n\nclass Transaction {\n  /**\n   * @param {string} fromAddress\n   * @param {string} toAddress\n   * @param {number} amount\n   */\n  constructor(fromAddress, toAddress, amount) {\n    this.fromAddress = fromAddress;\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.timestamp = Date.now();\n  }\n  /**\n   * Creates a SHA256 hash of the transaction\n   *\n   * @returns {string}\n   */\n\n\n  calculateHash() {\n    return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp).toString();\n  }\n  /**\n   * Signs a transaction with the given signingKey (which is an Elliptic keypair\n   * object that contains a private key). The signature is then stored inside the\n   * transaction object and later stored on the blockchain.\n   *\n   * @param {string} signingKey\n   */\n\n\n  signTransaction(signingKey) {\n    // You can only send a transaction from the wallet that is linked to your\n    // key. So here we check if the fromAddress matches your publicKey\n    if (signingKey.getPublic('hex') !== this.fromAddress) {\n      throw new Error('You cannot sign transactions for other wallets!');\n    } // Calculate the hash of this transaction, sign it with the key\n    // and store it inside the transaction obect\n\n\n    const hashTx = this.calculateHash();\n    const sig = signingKey.sign(hashTx, 'base64');\n    this.signature = sig.toDER('hex');\n  }\n  /**\n   * Checks if the signature is valid (transaction has not been tampered with).\n   * It uses the fromAddress as the public key.\n   *\n   * @returns {boolean}\n   */\n\n\n  isValid() {\n    // If the transaction doesn't have a from address we assume it's a\n    // mining reward and that it's valid. You could verify this in a\n    // different way (special field for instance)\n    if (this.fromAddress === null) return true;\n\n    if (!this.signature || this.signature.length === 0) {\n      throw new Error('No signature in this transaction');\n    }\n\n    const publicKey = ec.keyFromPublic(this.fromAddress, 'hex');\n    return publicKey.verify(this.calculateHash(), this.signature);\n  }\n\n}\n\nclass Block {\n  /**\n   * @param {number} timestamp\n   * @param {Transaction[]} transactions\n   * @param {string} previousHash\n   */\n  constructor(timestamp, transactions, previousHash = '') {\n    this.previousHash = previousHash;\n    this.timestamp = timestamp;\n    this.transactions = transactions;\n    this.nonce = 0;\n    this.hash = this.calculateHash();\n  }\n  /**\n   * Returns the SHA256 of this block (by processing all the data stored\n   * inside this block)\n   *\n   * @returns {string}\n   */\n\n\n  calculateHash() {\n    return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\n  }\n  /**\n   * Starts the mining process on the block. It changes the 'nonce' until the hash\n   * of the block starts with enough zeros (= difficulty)\n   *\n   * @param {number} difficulty\n   */\n\n\n  mineBlock(difficulty) {\n    while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\n      this.nonce++;\n      this.hash = this.calculateHash();\n    }\n\n    console.log(`Block mined: ${this.hash}`);\n  }\n  /**\n   * Validates all the transactions inside this block (signature + hash) and\n   * returns true if everything checks out. False if the block is invalid.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasValidTransactions() {\n    for (const tx of this.transactions) {\n      if (!tx.isValid()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass Blockchain {\n  constructor() {\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = 2;\n    this.pendingTransactions = [];\n    this.miningReward = 100;\n  }\n  /**\n   * @returns {Block}\n   */\n\n\n  createGenesisBlock() {\n    return new Block(Date.parse('2017-01-01'), [], '0');\n  }\n  /**\n   * Returns the latest block on our chain. Useful when you want to create a\n   * new Block and you need the hash of the previous Block.\n   *\n   * @returns {Block[]}\n   */\n\n\n  getLatestBlock() {\n    return this.chain[this.chain.length - 1];\n  }\n  /**\n   * Takes all the pending transactions, puts them in a Block and starts the\n   * mining process. It also adds a transaction to send the mining reward to\n   * the given address.\n   *\n   * @param {string} miningRewardAddress\n   */\n\n\n  minePendingTransactions(miningRewardAddress) {\n    const rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);\n    this.pendingTransactions.push(rewardTx);\n    let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);\n    block.mineBlock(this.difficulty);\n    console.log('Block successfully mined!');\n    this.chain.push(block);\n    this.pendingTransactions = [];\n  }\n  /**\n   * Add a new transaction to the list of pending transactions (to be added\n   * next time the mining process starts). This verifies that the given\n   * transaction is properly signed.\n   *\n   * @param {Transaction} transaction\n   */\n\n\n  addTransaction(transaction) {\n    if (!transaction.fromAddress || !transaction.toAddress) {\n      throw new Error('Transaction must include from and to address');\n    } // Verify the transactiion\n\n\n    if (!transaction.isValid()) {\n      throw new Error('Cannot add invalid transaction to chain');\n    }\n\n    if (transaction.amount <= 0) {\n      throw new Error('Transaction amount should be higher than 0');\n    }\n\n    this.pendingTransactions.push(transaction);\n  }\n  /**\n   * Returns the balance of a given wallet address.\n   *\n   * @param {string} address\n   * @returns {number} The balance of the wallet\n   */\n\n\n  getBalanceOfAddress(address) {\n    let balance = 0;\n\n    for (const block of this.chain) {\n      for (const trans of block.transactions) {\n        if (trans.fromAddress === address) {\n          balance -= trans.amount;\n        }\n\n        if (trans.toAddress === address) {\n          balance += trans.amount;\n        }\n      }\n    }\n\n    return balance;\n  }\n  /**\n   * Returns a list of all transactions that happened\n   * to and from the given wallet address.\n   *\n   * @param  {string} address\n   * @return {Transaction[]}\n   */\n\n\n  getAllTransactionsForWallet(address) {\n    const txs = [];\n\n    for (const block of this.chain) {\n      for (const tx of block.transactions) {\n        if (tx.fromAddress === address || tx.toAddress === address) {\n          txs.push(tx);\n        }\n      }\n    }\n\n    return txs;\n  }\n  /**\n   * Loops over all the blocks in the chain and verify if they are properly\n   * linked together and nobody has tampered with the hashes. By checking\n   * the blocks it also verifies the (signed) transactions inside of them.\n   *\n   * @returns {boolean}\n   */\n\n\n  isChainValid() {\n    // Check if the Genesis block hasn't been tampered with by comparing\n    // the output of createGenesisBlock with the first block on our chain\n    const realGenesis = JSON.stringify(this.createGenesisBlock());\n\n    if (realGenesis !== JSON.stringify(this.chain[0])) {\n      return false;\n    } // Check the remaining blocks on the chain to see if there hashes and\n    // signatures are correct\n\n\n    for (let i = 1; i < this.chain.length; i++) {\n      const currentBlock = this.chain[i];\n\n      if (!currentBlock.hasValidTransactions()) {\n        return false;\n      }\n\n      if (currentBlock.hash !== currentBlock.calculateHash()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports.Blockchain = Blockchain;\nmodule.exports.Block = Block;\nmodule.exports.Transaction = Transaction;","map":{"version":3,"sources":["/home/dror/WebProjects/react/BlockchainProjectFront/node_modules/savjeecoin/src/blockchain.js"],"names":["SHA256","require","EC","ec","Transaction","constructor","fromAddress","toAddress","amount","timestamp","Date","now","calculateHash","toString","signTransaction","signingKey","getPublic","Error","hashTx","sig","sign","signature","toDER","isValid","length","publicKey","keyFromPublic","verify","Block","transactions","previousHash","nonce","hash","JSON","stringify","mineBlock","difficulty","substring","Array","join","console","log","hasValidTransactions","tx","Blockchain","chain","createGenesisBlock","pendingTransactions","miningReward","parse","getLatestBlock","minePendingTransactions","miningRewardAddress","rewardTx","push","block","addTransaction","transaction","getBalanceOfAddress","address","balance","trans","getAllTransactionsForWallet","txs","isChainValid","realGenesis","i","currentBlock","module","exports"],"mappings":"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","sourcesContent":["const SHA256 = require('crypto-js/sha256');\nconst EC = require('elliptic').ec;\nconst ec = new EC('secp256k1');\n\nclass Transaction {\n  /**\n   * @param {string} fromAddress\n   * @param {string} toAddress\n   * @param {number} amount\n   */\n  constructor(fromAddress, toAddress, amount) {\n    this.fromAddress = fromAddress;\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.timestamp = Date.now();\n  }\n\n  /**\n   * Creates a SHA256 hash of the transaction\n   *\n   * @returns {string}\n   */\n  calculateHash() {\n    return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp)\n      .toString();\n  }\n\n  /**\n   * Signs a transaction with the given signingKey (which is an Elliptic keypair\n   * object that contains a private key). The signature is then stored inside the\n   * transaction object and later stored on the blockchain.\n   *\n   * @param {string} signingKey\n   */\n  signTransaction(signingKey) {\n    // You can only send a transaction from the wallet that is linked to your\n    // key. So here we check if the fromAddress matches your publicKey\n    if (signingKey.getPublic('hex') !== this.fromAddress) {\n      throw new Error('You cannot sign transactions for other wallets!');\n    }\n    \n\n    // Calculate the hash of this transaction, sign it with the key\n    // and store it inside the transaction obect\n    const hashTx = this.calculateHash();\n    const sig = signingKey.sign(hashTx, 'base64');\n\n    this.signature = sig.toDER('hex');\n  }\n\n  /**\n   * Checks if the signature is valid (transaction has not been tampered with).\n   * It uses the fromAddress as the public key.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    // If the transaction doesn't have a from address we assume it's a\n    // mining reward and that it's valid. You could verify this in a\n    // different way (special field for instance)\n    if (this.fromAddress === null) return true;\n\n    if (!this.signature || this.signature.length === 0) {\n      throw new Error('No signature in this transaction');\n    }\n\n    const publicKey = ec.keyFromPublic(this.fromAddress, 'hex');\n    return publicKey.verify(this.calculateHash(), this.signature);\n  }\n}\n\nclass Block {\n  /**\n   * @param {number} timestamp\n   * @param {Transaction[]} transactions\n   * @param {string} previousHash\n   */\n  constructor(timestamp, transactions, previousHash = '') {\n    this.previousHash = previousHash;\n    this.timestamp = timestamp;\n    this.transactions = transactions;\n    this.nonce = 0;\n    this.hash = this.calculateHash();\n  }\n\n  /**\n   * Returns the SHA256 of this block (by processing all the data stored\n   * inside this block)\n   *\n   * @returns {string}\n   */\n  calculateHash() {\n    return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\n  }\n\n  /**\n   * Starts the mining process on the block. It changes the 'nonce' until the hash\n   * of the block starts with enough zeros (= difficulty)\n   *\n   * @param {number} difficulty\n   */\n  mineBlock(difficulty) {\n    while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\n      this.nonce++;\n      this.hash = this.calculateHash();\n    }\n\n    console.log(`Block mined: ${this.hash}`);\n  }\n\n  /**\n   * Validates all the transactions inside this block (signature + hash) and\n   * returns true if everything checks out. False if the block is invalid.\n   *\n   * @returns {boolean}\n   */\n  hasValidTransactions() {\n    for (const tx of this.transactions) {\n      if (!tx.isValid()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nclass Blockchain {\n  constructor() {\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = 2;\n    this.pendingTransactions = [];\n    this.miningReward = 100;\n  }\n\n  /**\n   * @returns {Block}\n   */\n  createGenesisBlock() {\n    return new Block(Date.parse('2017-01-01'), [], '0');\n  }\n\n  /**\n   * Returns the latest block on our chain. Useful when you want to create a\n   * new Block and you need the hash of the previous Block.\n   *\n   * @returns {Block[]}\n   */\n  getLatestBlock() {\n    return this.chain[this.chain.length - 1];\n  }\n\n  /**\n   * Takes all the pending transactions, puts them in a Block and starts the\n   * mining process. It also adds a transaction to send the mining reward to\n   * the given address.\n   *\n   * @param {string} miningRewardAddress\n   */\n  minePendingTransactions(miningRewardAddress) {\n    const rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);\n    this.pendingTransactions.push(rewardTx);\n\n    let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);\n    block.mineBlock(this.difficulty);\n\n    console.log('Block successfully mined!');\n    this.chain.push(block);\n\n    this.pendingTransactions = [];\n  }\n\n  /**\n   * Add a new transaction to the list of pending transactions (to be added\n   * next time the mining process starts). This verifies that the given\n   * transaction is properly signed.\n   *\n   * @param {Transaction} transaction\n   */\n  addTransaction(transaction) {\n    if (!transaction.fromAddress || !transaction.toAddress) {\n      throw new Error('Transaction must include from and to address');\n    }\n\n    // Verify the transactiion\n    if (!transaction.isValid()) {\n      throw new Error('Cannot add invalid transaction to chain');\n    }\n    \n    if (transaction.amount <= 0) {\n      throw new Error('Transaction amount should be higher than 0');\n    }\n\n    this.pendingTransactions.push(transaction);\n  }\n\n  /**\n   * Returns the balance of a given wallet address.\n   *\n   * @param {string} address\n   * @returns {number} The balance of the wallet\n   */\n  getBalanceOfAddress(address) {\n    let balance = 0;\n\n    for (const block of this.chain) {\n      for (const trans of block.transactions) {\n        if (trans.fromAddress === address) {\n          balance -= trans.amount;\n        }\n\n        if (trans.toAddress === address) {\n          balance += trans.amount;\n        }\n      }\n    }\n\n    return balance;\n  }\n\n  /**\n   * Returns a list of all transactions that happened\n   * to and from the given wallet address.\n   *\n   * @param  {string} address\n   * @return {Transaction[]}\n   */\n  getAllTransactionsForWallet(address) {\n    const txs = [];\n\n    for (const block of this.chain) {\n      for (const tx of block.transactions) {\n        if (tx.fromAddress === address || tx.toAddress === address) {\n          txs.push(tx);\n        }\n      }\n    }\n\n    return txs;\n  }\n\n  /**\n   * Loops over all the blocks in the chain and verify if they are properly\n   * linked together and nobody has tampered with the hashes. By checking\n   * the blocks it also verifies the (signed) transactions inside of them.\n   *\n   * @returns {boolean}\n   */\n  isChainValid() {\n    // Check if the Genesis block hasn't been tampered with by comparing\n    // the output of createGenesisBlock with the first block on our chain\n    const realGenesis = JSON.stringify(this.createGenesisBlock());\n\n    if (realGenesis !== JSON.stringify(this.chain[0])) {\n      return false;\n    }\n\n    // Check the remaining blocks on the chain to see if there hashes and\n    // signatures are correct\n    for (let i = 1; i < this.chain.length; i++) {\n      const currentBlock = this.chain[i];\n\n      if (!currentBlock.hasValidTransactions()) {\n        return false;\n      }\n\n      if (currentBlock.hash !== currentBlock.calculateHash()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nmodule.exports.Blockchain = Blockchain;\nmodule.exports.Block = Block;\nmodule.exports.Transaction = Transaction;\n"]},"metadata":{},"sourceType":"script"}